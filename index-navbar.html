<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ELIXIR</title>
    <style>
      :root {
        --pad: 30px;
        --text-color: #080232;
        --glass-color: rgba(255, 255, 255, 0.2);
        --glass-stroke-color: rgba(255, 255, 255, 0.3);
        --cta-color: #0f0f0f;
        --cta-hover-color: #333333;
        --cta-text-color: #ffffff;
      }

      /* Minimal reset + backdrop */
      * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
      html, body { height: 100%; margin: 0; }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
        color: #000;
        background: linear-gradient(0deg, #b29fa3, #d2cacc);
        overflow-x: hidden;
      }
      a { color: inherit; text-decoration: none; }
      button { appearance: none; border: 0; background: none; padding: 0; font: inherit; cursor: pointer; }

      /* Utilities */
      .glass-bg { background: var(--glass-color); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); }
      .D9 { font-size: 12px; line-height: 1.5em; font-weight: 400; }
      .D5 { font-size: 24px; line-height: 1.2em; font-weight: 400; }
      .D8 { font-size: 14px; line-height: 1.2em; font-weight: 400; }
      .D-mobile-menu { font-size: 34px; line-height: 1.2em; font-weight: 400; }

      /* Logo */
      .logo.svelte-na9uof {
        position: absolute; top: var(--pad); left: var(--pad);
        width: 96px; height: 53px; z-index: 2; display: grid; place-items: center;
      }
      .logo.svelte-na9uof svg { display: block; width: 96px; height: 53px; }

      /* Desktop nav */
      .nav.svelte-na9uof {
        position: absolute; top: var(--pad); right: var(--pad);
        display: flex; height: 47px; margin: 8px; border-radius: 3px; z-index: 1; font-size: 14px;
      }
      .nav_stroke.svelte-na9uof { position: absolute; top: -11px; right: -11px; bottom: -11px; left: -11px; pointer-events: none; }
      .nav_links.svelte-na9uof { display: flex; align-items: center; }
      .nav_link.svelte-na9uof { color: var(--text-color); text-decoration: none; padding: 0 15px; transition: .3s opacity; }
      .nav_link.svelte-na9uof:first-of-type { padding-left: 30px; }
      .nav_link.svelte-na9uof:last-of-type { padding-right: 30px; }
      .nav_links.svelte-na9uof:hover .nav_link.svelte-na9uof { opacity: .6; }
      .nav_links.svelte-na9uof:hover .nav_link.svelte-na9uof:hover { opacity: 1; }
      .nav_button.svelte-na9uof {
        display: flex; align-items: center; padding: 0 30px; border-radius: 0 3px 3px 0;
        color: var(--cta-text-color); background: var(--cta-color); transition: .3s background-color, .3s color;
      }
      .nav_button.svelte-na9uof:hover { background: var(--cta-hover-color); }

      /* Mobile nav */
      .mobile-nav.svelte-na9uof { display: none; position: absolute; top: var(--pad); right: var(--pad); margin: 8px; z-index: 2; }
      .menu-prompt.svelte-na9uof { width: 37px; height: 37px; border-radius: 3px; margin-right: 4px; display: grid; place-items: center; }
      .menu-prompt_icon.svelte-na9uof svg { fill: var(--text-color); display: block; }
      .mobile-nav.svelte-na9uof .nav_button.svelte-na9uof { border-radius: 3px; padding: 0 20px; }

      /* Backdrop + mobile menu panel */
      .click-catch.svelte-na9uof { display: none; position: fixed; inset: 0; z-index: 1; background: rgba(13, 17, 19, 0.325); }
      .mobile-menu.svelte-na9uof {
        display: none; position: fixed; flex-direction: column; top: 110px; left: 0; right: 0; margin: auto; z-index: 3;
        max-width: 400px; width: calc(100% - 2 * var(--pad) - 16px); box-sizing: border-box;
        padding: 5px 20px 20px; border-radius: 6px;
      }
      .mobile-menu_links.svelte-na9uof { display: flex; flex-direction: column; }
      .mobile-menu_link.svelte-na9uof { display: flex; height: 2.2em; align-items: center; color: #00000059; border-bottom: .5px solid rgba(255,255,255,0.2); }
      .mobile-menu_link.svelte-na9uof:last-of-type { border-bottom: none; }
      .buy-block.svelte-na9uof { display: flex; width: 100%; justify-content: space-between; align-items: center; margin-top: 70px; }
      .buy-block_left.svelte-na9uof { display: flex; flex-direction: column; }
      .buy-block_cta.svelte-na9uof { display: block; color: #000; background: #fff; min-width: 70px; padding: 10px 15px; text-align: center; border-radius: 3px; cursor: pointer; }

      /* Flying border SVG base styling */
      .flying-border { width: 100%; height: 100%; }
      .flying-border rect { vector-effect: non-scaling-stroke; }
  .flying-border .fb-static-outer { stroke: #ffffff; stroke-width: 3; stroke-linecap: round; fill: none; }
  .flying-border .fb-static-inner { stroke: rgba(255,255,255,0.3); stroke-width: 1; stroke-linecap: round; fill: none; }
  .flying-border .fb-runner { stroke: #ffffff; stroke-width: 3; stroke-linecap: round; fill: none; }
  .flying-border .fb-runner-ghost { stroke: rgba(255,255,255,0.5); stroke-width: 1; stroke-linecap: round; fill: none; }

      /* Responsive */
      @media (max-width: 768px) {
        :root { --pad: 25px; }
        .nav.svelte-na9uof { display: none; }
        .mobile-nav.svelte-na9uof { display: flex; align-items: center; }
      }

      main { min-height: 140vh; }
    </style>
  </head>
  <body>
    <!-- Desktop logo and nav -->
    <a href="/" class="logo svelte-na9uof" aria-label="Home">
      <!-- Inline placeholder logo (no external asset) -->
      <svg viewBox="0 0 96 53" aria-hidden="true">
        <rect x="0.5" y="0.5" width="95" height="52" rx="6" fill="#080232"/>
        <text x="48" y="33" text-anchor="middle" font-family="system-ui, -apple-system, Inter, sans-serif" font-size="18" fill="#fff">ELIXIR</text>
      </svg>
    </a>

    <div class="nav D9 glass-bg svelte-na9uof" role="navigation" aria-label="Primary">
  <div class="nav_stroke svelte-na9uof"></div>
      <div class="nav_links svelte-na9uof">
        <a href="/" class="nav_link svelte-na9uof">Home</a>
        <a href="/setup" class="nav_link svelte-na9uof">Setup</a>
        <a href="/plans" class="nav_link svelte-na9uof">Plans</a>
        <a href="/about" class="nav_link svelte-na9uof">About</a>
        <a href="/faq" class="nav_link svelte-na9uof">FAQ</a>
      </div>
      <a href="/booking" class="nav_button svelte-na9uof">ELIXIR</a>
    </div>

    <!-- Mobile nav (shown via CSS @media) -->
    <div class="mobile-nav svelte-na9uof" role="navigation" aria-label="Primary mobile">
      <div class="nav_stroke svelte-na9uof"></div>
      <div id="menuPrompt" class="menu-prompt glass-bg svelte-na9uof" aria-label="Toggle menu" aria-expanded="false" aria-controls="mobileMenu" role="button" tabindex="0">
        <!-- Icon container; weâ€™ll swap the inner SVGs in JS to match the compiled markup -->
        <div class="menu-prompt_icon svelte-na9uof" data-icon="burger">
          <svg width="37" height="37" viewBox="0 0 37 37" xmlns="http://www.w3.org/2000/svg" fill="#080232" class="svelte-na9uof">
            <rect x="9" y="18" width="19" height="1"></rect>
            <rect x="9" y="22" width="19" height="1"></rect>
            <rect x="9" y="14" width="19" height="1"></rect>
          </svg>
        </div>
      </div>
      <a href="/booking" class="nav_button glass-bg D9 svelte-na9uof">ELIXIR</a>
    </div>

    <!-- Backdrop and mobile menu -->
    <div id="clickCatch" class="click-catch svelte-na9uof" hidden></div>
    <div id="mobileMenu" class="mobile-menu glass-bg svelte-na9uof" aria-hidden="true">
      <div class="nav_stroke svelte-na9uof"></div>
      <div class="mobile-menu_links D-mobile-menu svelte-na9uof">
        <a href="/" class="mobile-menu_link svelte-na9uof">Home</a>
        <a href="/setup" class="mobile-menu_link svelte-na9uof">Setup</a>
        <a href="/plans" class="mobile-menu_link svelte-na9uof">Plans</a>
        <a href="/about" class="mobile-menu_link svelte-na9uof">About</a>
        <a href="/faq" class="mobile-menu_link svelte-na9uof">FAQ</a>
      </div>
    </div>

    <main></main>

    <script>
      (function(){
        /* Mobile menu interactions */
        const menuPrompt = document.getElementById('menuPrompt');
        const clickCatch = document.getElementById('clickCatch');
        const mobileMenu = document.getElementById('mobileMenu');

        const burgerIcon = `
          <div class="menu-prompt_icon svelte-na9uof">
            <svg width="37" height="37" viewBox="0 0 37 37" xmlns="http://www.w3.org/2000/svg" fill="#080232" class="svelte-na9uof">
              <rect x="9" y="18" width="19" height="1"></rect>
              <rect x="9" y="22" width="19" height="1"></rect>
              <rect x="9" y="14" width="19" height="1"></rect>
            </svg>
          </div>`;
        const closeIcon = `
          <div class="menu-prompt_icon svelte-na9uof">
            <svg width="37" height="37" viewBox="0 0 37 37" xmlns="http://www.w3.org/2000/svg" fill="#080232" class="svelte-na9uof">
              <rect x="11" y="25.4351" width="19" height="1" transform="rotate(-45 11 25.4351)"></rect>
              <rect x="11.707" y="12.0005" width="19" height="1" transform="rotate(45 11.707 12.0005)"></rect>
            </svg>
          </div>`;

        function openMenu(){
          menuPrompt.setAttribute('aria-expanded','true');
          clickCatch.hidden = false;
          mobileMenu.setAttribute('aria-hidden','false');
          // Show elements by overriding display:none from CSS when mobile
          clickCatch.style.display = 'flex';
          mobileMenu.style.display = 'flex';
          menuPrompt.innerHTML = closeIcon;
          document.addEventListener('keydown', onKeyDown);
        }
        function closeMenu(){
          menuPrompt.setAttribute('aria-expanded','false');
          mobileMenu.setAttribute('aria-hidden','true');
          clickCatch.hidden = true;
          clickCatch.style.display = 'none';
          mobileMenu.style.display = 'none';
          menuPrompt.innerHTML = burgerIcon;
          document.removeEventListener('keydown', onKeyDown);
        }
        function toggleMenu(){
          const expanded = menuPrompt.getAttribute('aria-expanded') === 'true';
          expanded ? closeMenu() : openMenu();
        }
        function onKeyDown(e){ if(e.key === 'Escape') closeMenu(); }

        menuPrompt.addEventListener('click', toggleMenu);
        menuPrompt.addEventListener('keypress', (e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleMenu(); }});
        clickCatch.addEventListener('click', closeMenu);
        // Close on navigation click in mobile menu
        mobileMenu.addEventListener('click', (e)=>{ if(e.target.closest('a')) closeMenu(); });

        /* Flying border effect mirroring the Svelte Border component */
        function initFlyingBorder(hostEl, options = {}) {
          if (!hostEl) return () => {};
          const strokeHost = hostEl.querySelector('.nav_stroke.svelte-na9uof');
          if (!strokeHost) return () => {};

          strokeHost.innerHTML = '';

          const defaults = {
            radius: 8,
            tail: 10,
            gap: 10,
            ease: 0.1,
            hoverAxis: 'x',
            isBottom: false,
            isTop: false
          };
          const cfg = Object.assign({}, defaults, options);
          if (options.hoverHorizontal === false) cfg.hoverAxis = 'y';

          const NS = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(NS, 'svg');
          svg.classList.add('flying-border');

          const rectPrimary = document.createElementNS(NS, 'rect');
          rectPrimary.setAttribute('class', 'fb-runner');
          const rectSecondary = document.createElementNS(NS, 'rect');
          rectSecondary.setAttribute('class', 'fb-static-outer');
          const rectTailInner = document.createElementNS(NS, 'rect');
          rectTailInner.setAttribute('class', 'fb-static-inner');
          const rectTailOuter = document.createElementNS(NS, 'rect');
          rectTailOuter.setAttribute('class', 'fb-runner-ghost');

          svg.appendChild(rectPrimary);
          svg.appendChild(rectSecondary);
          svg.appendChild(rectTailInner);
          svg.appendChild(rectTailOuter);
          strokeHost.appendChild(svg);

          const metrics = {
            perimeter: 0,
            arcQuarter: 0,
            runnerSegment: 0,
            runnerHead: 0,
            widthSpan: 0,
            bases: {
              primaryStart: 0, // B
              primaryEnd: 0,   // V
              secondaryStart: 0, // _
              secondaryEnd: 0,   // z
              wrap: 0           // $
            }
          };

          const state = {
            hoverX: 0.5,
            hoverY: 0.5,
            isHover: false
          };

          const primary = { target: 0, eased: 0 };
          const secondary = { target: 0, eased: 0 };

          let hostRect = hostEl.getBoundingClientRect();
          let rafId;

          const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
          const mix = (a, b, t) => a * (1 - t) + b * t;

          function setRectGeometry(width, height, radius) {
            const innerW = Math.max(0, width - 3);
            const innerH = Math.max(0, height - 3);
            [rectPrimary, rectSecondary, rectTailInner, rectTailOuter].forEach(rect => {
              rect.setAttribute('x', '1.5');
              rect.setAttribute('y', '1.5');
              rect.setAttribute('width', innerW);
              rect.setAttribute('height', innerH);
              rect.setAttribute('rx', radius);
            });
          }

          function recalcGeometry() {
            hostRect = hostEl.getBoundingClientRect();
            const width = Math.max(0, hostRect.width + 22);
            const height = Math.max(0, hostRect.height + 22);
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            const innerW = Math.max(0, width - 3);
            const innerH = Math.max(0, height - 3);
            const radius = Math.min(cfg.radius, Math.max(0, Math.min(innerW, innerH) / 2));
            setRectGeometry(width, height, radius);

            const perimeter = rectPrimary.getTotalLength ? rectPrimary.getTotalLength() : 2 * (innerW + innerH);
            metrics.perimeter = perimeter;
            metrics.arcQuarter = 2 * Math.PI * radius * 0.25;
            metrics.runnerSegment = metrics.arcQuarter + cfg.tail * 2;
            metrics.runnerHead = metrics.arcQuarter + cfg.tail;
            metrics.widthSpan = Math.max(0, innerW - radius * 2);

            metrics.bases.primaryStart = metrics.runnerHead;
            metrics.bases.primaryEnd = -metrics.widthSpan - metrics.arcQuarter + metrics.runnerHead;
            metrics.bases.secondaryStart = metrics.runnerHead - perimeter * 0.5;
            metrics.bases.secondaryEnd = -perimeter * 0.5 - metrics.widthSpan - metrics.arcQuarter + metrics.runnerHead;
            metrics.bases.wrap = metrics.bases.secondaryEnd + perimeter;

            const defaultPrimary = cfg.isBottom ? metrics.bases.secondaryEnd : metrics.bases.primaryStart;
            const defaultSecondary = cfg.isTop ? metrics.bases.primaryEnd : metrics.bases.secondaryStart;
            primary.eased = primary.target = defaultPrimary;
            secondary.eased = secondary.target = defaultSecondary;

            applyDashArrays();
          }

          function updateTargets() {
            if (!metrics.perimeter) return;

            if (state.isHover) {
              if ((cfg.hoverAxis || 'x').toLowerCase() === 'y') {
                const ratio = clamp(state.hoverY, 0, 1);
                primary.target = mix(metrics.bases.primaryStart, metrics.bases.wrap, ratio);
                secondary.target = mix(metrics.bases.primaryEnd, metrics.bases.secondaryStart, ratio);
              } else {
                const ratio = clamp(state.hoverX, 0, 1);
                primary.target = mix(metrics.bases.primaryStart, metrics.bases.primaryEnd, ratio);
                secondary.target = mix(metrics.bases.secondaryEnd, metrics.bases.secondaryStart, ratio);
              }
            } else {
              primary.target = cfg.isBottom ? metrics.bases.secondaryEnd : metrics.bases.primaryStart;
              secondary.target = cfg.isTop ? metrics.bases.primaryEnd : metrics.bases.secondaryStart;
            }
          }

          function applyDashArrays() {
            if (!metrics.perimeter) return;

            const segment = Math.min(metrics.perimeter, Math.max(1, metrics.runnerSegment));
            const mainGap = Math.max(0, metrics.perimeter - segment);
            rectPrimary.setAttribute('stroke-dasharray', `${segment} ${mainGap}`);
            rectPrimary.setAttribute('stroke-dashoffset', `${primary.eased}`);
            rectSecondary.setAttribute('stroke-dasharray', `${segment} ${mainGap}`);
            rectSecondary.setAttribute('stroke-dashoffset', `${secondary.eased}`);

            const tailLength = -secondary.eased + primary.eased - cfg.gap * 2 - segment;
            const leading = Math.max(0, tailLength);
            const leadingGap = Math.max(0, metrics.perimeter - leading);
            rectTailInner.setAttribute('stroke-dasharray', `${leading} ${leadingGap}`);
            rectTailInner.setAttribute('stroke-dashoffset', `${primary.eased - segment - cfg.gap}`);

            const trailingLength = metrics.perimeter + secondary.eased - primary.eased - cfg.gap * 2 - segment;
            const trailing = Math.max(0, trailingLength);
            const trailingGap = Math.max(0, metrics.perimeter - trailing);
            rectTailOuter.setAttribute('stroke-dasharray', `${trailing} ${trailingGap}`);
            rectTailOuter.setAttribute('stroke-dashoffset', `${secondary.eased - segment - cfg.gap + metrics.perimeter * 2}`);
          }

          function animate() {
            updateTargets();
            primary.eased += (primary.target - primary.eased) * cfg.ease;
            secondary.eased += (secondary.target - secondary.eased) * cfg.ease;
            applyDashArrays();
            rafId = requestAnimationFrame(animate);
          }

          function updateHoverFromRect(rect) {
            hostRect = hostEl.getBoundingClientRect();
            const centerX = (rect.left + rect.right) / 2;
            const centerY = (rect.top + rect.bottom) / 2;
            state.hoverX = clamp((centerX - hostRect.left) / (hostRect.width || 1), 0, 1);
            state.hoverY = clamp((centerY - hostRect.top) / (hostRect.height || 1), 0, 1);
          }

          function handleEnter(event) {
            state.isHover = true;
            updateHoverFromRect(event.currentTarget.getBoundingClientRect());
          }

          function handleLeave() {
            state.isHover = false;
          }

          const links = hostEl.querySelectorAll('a');
          links.forEach(link => {
            link.addEventListener('mouseenter', handleEnter);
            link.addEventListener('mouseleave', handleLeave);
          });
          hostEl.addEventListener('mouseleave', handleLeave);

          const ro = new ResizeObserver(recalcGeometry);
          ro.observe(hostEl);
          window.addEventListener('resize', recalcGeometry);

          recalcGeometry();
          animate();

          return () => {
            cancelAnimationFrame(rafId);
            ro.disconnect();
            window.removeEventListener('resize', recalcGeometry);
            links.forEach(link => {
              link.removeEventListener('mouseenter', handleEnter);
              link.removeEventListener('mouseleave', handleLeave);
            });
            hostEl.removeEventListener('mouseleave', handleLeave);
          };
        }

        // Initialize flying borders for desktop nav and mobile bits
        const desktopNav = document.querySelector('.nav.svelte-na9uof');
        const mobileBar = document.querySelector('.mobile-nav.svelte-na9uof');
        const mobilePanel = document.querySelector('#mobileMenu');
        initFlyingBorder(desktopNav);
        initFlyingBorder(mobileBar);
        initFlyingBorder(mobilePanel, { tail: 30, isBottom: true });
      })();
    </script>
  </body>
</html>
