<!doctype html>
<html lang="de">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>iOS26 Liquid Glass – Refraction Clone</title>
	<link rel="stylesheet" href="./ios-liquid-glass.css" />
	<!-- RealGlass library for true refraction + chromatic aberration (not just blur) -->
	<script src="https://cdn.jsdelivr.net/npm/realglass/RealGlass.standalone.js"></script>
	<!-- Helper to init once, avoid self-capture, and auto-apply to [data-realglass] -->
	<script defer src="../realglass-effect/realglass-helper.js"></script>
	<style>
		/* Keep the glass element hidden while the page-level screenshot is prepared */
		.rg-hidden-until-ready.liquid-glass { display: none; }
	</style>
</head>
<body class="ios26-bg">
	<header class="hero">
		<div class="hero-inner">
			<h1>Liquid Glass</h1>
			<p>Refraction-first, chromatic edge – iOS26 vibe. Scroll underneath and watch it bend.</p>
		</div>
	</header>

	<main class="content">
		<!-- Lots of content to refract beneath the glass element -->
		<section>
			<h2>Darunterliegender Inhalt</h2>
			<p>
				Dieser Abschnitt ist absichtlich reichhaltig, damit du beim Scrollen siehst, wie das Glas
				den Hintergrund bricht. Der Effekt basiert nicht auf einfachem Blur, sondern nutzt
				eine Screenshot-basierte Brechung mit leichtem Farbsäumen an den Rändern.
			</p>
			<p>
				Die Kanten zeigen eine subtile chromatische Aberration, während ein sanftes Highlight
				die Materialität betont.
			</p>
		</section>

		<section>
			<h2>Mehr Inhalt</h2>
			<p>
				Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent tincidunt, urna a dapibus
				egestas, neque mi facilisis sem, vitae fermentum magna lorem sed ante. Duis in velit nulla.
				Nunc posuere, ipsum id cursus pretium, lorem eros hendrerit mi, non vestibulum risus massa
				nec dolor.
			</p>
			<p>
				Integer at arcu sed arcu tristique dictum. Sed a mauris at diam gravida gravida. Cras
				ullamcorper, lacus in volutpat pretium, lorem dolor fermentum elit, non mollis eros tellus
				vel nibh. Nam faucibus est ac risus faucibus volutpat.
			</p>
		</section>

		<section>
			<h2>Noch mehr Inhalt</h2>
			<p>
				Suspendisse potenti. Pellentesque habitant morbi tristique senectus et netus et malesuada
				fames ac turpis egestas. Sed ac nisl non justo finibus maximus quis sed quam. Vivamus quis
				efficitur magna. In hac habitasse platea dictumst.
			</p>
		</section>
	</main>

	<!-- Liquid glass element: real refraction + CA. Fixed in the viewport. -->
	<div id="liquidGlass"
			 class="liquid-glass rg-fade-in"
			 data-realglass
			 data-realglass-options='{
				 "frosting": 0,
				 "borderRadius": 24,
				 "lightStrength": 0.2,
				 "chromaticAberration": 1.05,
				 "glassOpacity": 0.1,
				 "lightX": 0.1,
				 "lightY": 0.1,
				 "edgeSmoothness": 3.0,
				 "ior": 2,
				 "specularShininess": 52,
				 "thickness": 2.5,
				 "tintColor": [0.95, 0.98, 1.0],
				 "tintStrength": 0.06
			 }'>
		<div class="glass-inner">
			<span class="label">Liquid</span>
			<span class="label subtle">Glass</span>
		</div>
					<!-- Stroke overlay for the navbar-style hover effect -->
					<div class="nav_stroke"></div>
	</div>

		<script>
			// Navbar-like flying border, adapted to hover the entire glass container
				(function(){
				const hostEl = document.getElementById('liquidGlass');
				if (!hostEl) return;
				const strokeHost = hostEl.querySelector('.nav_stroke');
				if (!strokeHost) return;
				strokeHost.innerHTML = '';

					const cfg = { tail: 18, gap: 10, ease: 0.12 };
				const NS = 'http://www.w3.org/2000/svg';
				const svg = document.createElementNS(NS, 'svg');
				svg.classList.add('flying-border');
				const rectPrimary = document.createElementNS(NS, 'rect'); rectPrimary.setAttribute('class','fb-runner');
				const rectSecondary = document.createElementNS(NS, 'rect'); rectSecondary.setAttribute('class','fb-static-outer');
				const rectTailInner = document.createElementNS(NS, 'rect'); rectTailInner.setAttribute('class','fb-static-inner');
				const rectTailOuter = document.createElementNS(NS, 'rect'); rectTailOuter.setAttribute('class','fb-runner-ghost');
				svg.appendChild(rectPrimary); svg.appendChild(rectSecondary); svg.appendChild(rectTailInner); svg.appendChild(rectTailOuter);
				strokeHost.appendChild(svg);

				const metrics = { perimeter: 0, arcQuarter: 0, runnerSegment: 0, runnerHead: 0, widthSpan: 0, bases: {} };
				const state = { hoverX: 0.5, hoverY: 0.5, isHover: false };
				const primary = { target: 0, eased: 0 };
				const secondary = { target: 0, eased: 0 };

				const clamp = (v, a, b) => Math.min(Math.max(v, a), b);
				const mix = (a, b, t) => a * (1 - t) + b * t;

										function getHostRadius(){
											const cs = getComputedStyle(hostEl);
											// Prefer top-left (single corner) because getComputedStyle may return compound values
											const raw = cs.borderTopLeftRadius || cs.borderRadius || '0px';
											// raw can be like "32px" or "32px 32px" or "50%" or "50% 50%" or "32px / 32px"
											// Extract the first token before space or '/'
											const token = String(raw).split(/[\s\/]+/)[0];
											let r = 0;
											if (token.endsWith('%')){
												const pct = parseFloat(token);
												if (isFinite(pct)){
													const rect = hostEl.getBoundingClientRect();
													// Per CSS spec, percentage radii are relative to corresponding box dimensions; for a uniform rx use min axis
													r = Math.min(rect.width, rect.height) * (pct / 100);
												}
											} else {
												const m = /([\d.]+)px/.exec(token);
												r = m ? parseFloat(m[1]) : 0;
											}
											return isFinite(r) ? r : 0;
										}

				function setRectGeometry(width, height, radius) {
					const innerW = Math.max(0, width - 3);
					const innerH = Math.max(0, height - 3);
					[rectPrimary, rectSecondary, rectTailInner, rectTailOuter].forEach(rect => {
						rect.setAttribute('x', '1.5');
						rect.setAttribute('y', '1.5');
						rect.setAttribute('width', innerW);
						rect.setAttribute('height', innerH);
						rect.setAttribute('rx', radius);
					});
				}

								function recalcGeometry(){
					const hostRect = hostEl.getBoundingClientRect();
									const OUTSET = 11;         // nav_stroke overlay extends this many px beyond each side
									const STROKE_INSET = 1.5;  // rect x/y inset used for 3px strokes (centered)
									const width = Math.max(0, hostRect.width + OUTSET * 2);
									const height = Math.max(0, hostRect.height + OUTSET * 2);
					svg.setAttribute('width', width);
					svg.setAttribute('height', height);
					svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

					const innerW = Math.max(0, width - 3);
					const innerH = Math.max(0, height - 3);
									// Offset the runner radius to match the host's curvature despite the outward overlay and the stroke inset
									const desired = getHostRadius() + (OUTSET - STROKE_INSET);
									const radius = Math.min(desired, Math.max(0, Math.min(innerW, innerH) / 2));
					setRectGeometry(width, height, radius);

					const perimeter = rectPrimary.getTotalLength ? rectPrimary.getTotalLength() : 2 * (innerW + innerH);
					metrics.perimeter = perimeter;
					metrics.arcQuarter = 2 * Math.PI * radius * 0.25;
					metrics.runnerSegment = metrics.arcQuarter + cfg.tail * 2;
					metrics.runnerHead = metrics.arcQuarter + cfg.tail;
					metrics.widthSpan = Math.max(0, innerW - radius * 2);

					metrics.bases = {
						primaryStart: metrics.runnerHead,
						primaryEnd: -metrics.widthSpan - metrics.arcQuarter + metrics.runnerHead,
						secondaryStart: metrics.runnerHead - perimeter * 0.5,
						secondaryEnd: -perimeter * 0.5 - metrics.widthSpan - metrics.arcQuarter + metrics.runnerHead,
						wrap: -perimeter * 0.5 - metrics.widthSpan - metrics.arcQuarter + metrics.runnerHead + perimeter
					};

					primary.eased = primary.target = metrics.bases.primaryStart;
					secondary.eased = secondary.target = metrics.bases.secondaryStart;
					applyDashArrays();
				}

				function applyDashArrays(){
					if (!metrics.perimeter) return;
					const segment = Math.min(metrics.perimeter, Math.max(1, metrics.runnerSegment));
					const mainGap = Math.max(0, metrics.perimeter - segment);
					rectPrimary.setAttribute('stroke-dasharray', `${segment} ${mainGap}`);
					rectPrimary.setAttribute('stroke-dashoffset', `${primary.eased}`);
					rectSecondary.setAttribute('stroke-dasharray', `${segment} ${mainGap}`);
					rectSecondary.setAttribute('stroke-dashoffset', `${secondary.eased}`);

					const tailLength = -secondary.eased + primary.eased - cfg.gap * 2 - segment;
					const leading = Math.max(0, tailLength);
					const leadingGap = Math.max(0, metrics.perimeter - leading);
					rectTailInner.setAttribute('stroke-dasharray', `${leading} ${leadingGap}`);
					rectTailInner.setAttribute('stroke-dashoffset', `${primary.eased - segment - cfg.gap}`);

					const trailingLength = metrics.perimeter + secondary.eased - primary.eased - cfg.gap * 2 - segment;
					const trailing = Math.max(0, trailingLength);
					const trailingGap = Math.max(0, metrics.perimeter - trailing);
					rectTailOuter.setAttribute('stroke-dasharray', `${trailing} ${trailingGap}`);
					rectTailOuter.setAttribute('stroke-dashoffset', `${secondary.eased - segment - cfg.gap + metrics.perimeter * 2}`);
				}

				function updateTargets(){
					if (!metrics.perimeter) return;
					if (state.isHover){
						const ratio = clamp(state.hoverX, 0, 1);
						primary.target = mix(metrics.bases.primaryStart, metrics.bases.primaryEnd, ratio);
						secondary.target = mix(metrics.bases.secondaryEnd, metrics.bases.secondaryStart, ratio);
					} else {
						primary.target = metrics.bases.primaryStart;
						secondary.target = metrics.bases.secondaryStart;
					}
				}

				function animate(){
					updateTargets();
					primary.eased += (primary.target - primary.eased) * cfg.ease;
					secondary.eased += (secondary.target - secondary.eased) * cfg.ease;
					applyDashArrays();
					requestAnimationFrame(animate);
				}

				function onEnter(){ state.isHover = true; }
				function onLeave(){ state.isHover = false; }
				function onMove(e){
					const r = hostEl.getBoundingClientRect();
					state.hoverX = clamp((e.clientX - r.left) / (r.width || 1), 0, 1);
					state.hoverY = clamp((e.clientY - r.top) / (r.height || 1), 0, 1);
				}

				hostEl.addEventListener('mouseenter', onEnter);
				hostEl.addEventListener('mouseleave', onLeave);
				hostEl.addEventListener('mousemove', onMove, { passive: true });
				window.addEventListener('resize', recalcGeometry);
				new ResizeObserver(recalcGeometry).observe(hostEl);

				recalcGeometry();
				animate();
			})();
		</script>
</body>
</html>
